\section{Sequence alignment}
In this section we would like to deeply explain what is sequence alignment as it is one of the most essential task in bioinformatics.
Because of its usage in some form in almost all task related to biological sequences, we will describe possibilities of its application.
As there are two main types of sequence alignment, we will describe both of them with emphasizing the differences.
We will also go through the basic algorithm used for solving these problems.
At the end of this section we will describe, how we used them in our analysis.

\subsection{Global alignment}

\subsubsection{Usage}
Global alignment is commonly used from comparison between sequences from their beginning to their end.
This comparison can help us to discover mutations in sequence, which cause certain phenotype or to determine highly conserved regions with a potential to carry a gene.
The relationships between conserved regions and mutations in certain sequences often serves as a basic assumptions for construction of phylogenetic trees.
Therefore, it can tell us a lot about the nature of evolution.
Global alignment is also capable of calculating similarity score for two sequences.
In general, it is mostly used when comparing sequences with roughly the same length.

\subsubsection{Problem statement}
Let the input for the problem be set of two sequences consisting of nucleotides.
For example, $ X = ATTGATGG $ and $ Y = AATTCAAC $.
Then the output is represented as matrix, where each row is one sequence with possible gaps between nucleotides.
We can see potential solutions in the Table (\ref{tab:potsol})

\begin{table}
  \centering
    \begin{tabular}{ l | r }
    \verb|A-TTGATGG| & \verb|-ATTG-ATGG| \\
    \verb|AATTCAAC-| & \verb|AATTCAAC--| \\
    \end{tabular}
  \caption{Global alignment examples}
  \label{tab:potsol}
\end{table} 

As we can see, every alignment could have more than one valid solution.
Despite of multiple possible solutions, not every solution is equally good.
Typically, we want to find the best possible solution to this problem.
For this purpose, we use scoring scheme.
Scoring scheme consists of rules, which add numerical value to each column of pairwise alignment.
For example, we can evaluate match in column with score $+1$, mismatch with score $-1$ and alignment to gap with score $-1$.
With this scoring scheme, we can evaluate quality of particular alignment.
For alignment on the left side of the Table (\ref{tab:potsol}), resulting score is $+1-1+1+1-1+1-1-1-1 = -1$ and for alignment on the right side of the Table (\ref{tab:potsol}) $-1+1+1+1-1-1+1-1-1-1 = -2$.
From this example, we can clearly see, that according to our scoring scheme alignment on the left is better.

\subsubsection{Scoring}
In practice we could use more complex scoring scheme, which better reflects reality.
For example substitution between purines (adenine, guanine) or substitution between pyrimidines (cytosine, thymine) occur more often, because they do not require change in the number of rings in the chemical structure of these nucleotides.
Another example, when more complex scoring scheme is inevitable is aligning of two proteins.
Amino acids differ in many parameters as polarity, size and structure of their side chains.
This influences the probability of substitution between two amino acids.
Therefore, it is much more likely that Leucine will be substituted for Isoleucine, than substituted for Aspartic Acid.
To solve the complexity of substitutions between amino acids, matrix BLOSUM62 (\ref{fig:blosum}) was created.
Another layer of complexity, which reflects reality better, is affine gap penalty function.
This reflects the fact that insertions and deletions do not usually occur only on one nucleotide, but often a longer region of DNA is deleted or inserted.
Affine gap penalty solves this issue by higher negative score for opening a new gap in alignment and a lower negative gap for extension of already created gap.

\begin{figure}[ht]
  \centering
    \includegraphics[width=\textwidth]{./images/blosum62.png}
  \caption{BLOSUM62}
  \label{fig:blosum}
\end{figure}

% end of session 16.04.2018

\subsubsection{Needleman-Wunsch algorithm}
For searching optimal global alignment we usually use Needleman-Wunsch algorithm.
It is an algorithm from group of dynamic programming algorithms.
This means, the main problem is divided into smaller problems, which are computable more easily and solutions to them are stored in memory.
At each occurrence of a small problem, we can look into stored solutions, where we can find it. 
Then the main problem is reconstructed from already computed subproblems.
Dynamic programming algorithms offer saving time on computation at the expense of higher memory usage.

\begin{figure}[ht]
  \centering
    \includegraphics[width=\textwidth]{./images/needle_wunsch.png}
  \caption{Needleman-Wunsch}
  \label{fig:glal}
\end{figure}

Needleman-Wunsch algorithm produces table as in the Figure (\ref{fig:glal}). 
It starts by putting the first sequence we want to align to first row and the second sequence to first column.
Before each sequence there is one gap to cover the case if we would not want to align first letter of particular sequence right from beginning.
The table is then initialized with series starting from 0 and decreasing by 1 each step on the second row and with the same series on the second column.
After initialization the table starts to be filled from top left corner following this rule:\\
Into each cell $A_{i,j}$ write maximum of:
\begin{itemize}
\item $A_{i-1, j-1} + s()$,
\item $A_{i-1, j} + g()$,
\item $A_{i, j-1} + g()$,
\end{itemize}
where s() returns score of match/mismatch from scoring scheme and g() returns score of gap penalty (possibly affine gap).
The final score of the alignment can be found in the bottom right corner of filled table.
Specific alignments can be found by tracking all possible paths to this value.
The time and space complexity of Needleman-Wunsch algorithm is $\mathcal{O}(nm)$, where $n$ is the length of the first sequence and $m$ is the length of the second sequence.

\subsection{Local alignment}
\subsubsection{Usage}
In comparison with global alignment, local alignment search for regions inside sequences with high similarities and does not provide alignment from beginning to end.
It is generally useful when searching for a small subsequence inside vast sequence.
For example, searching for a gene inside whole bacterial genome.
It can be also used when comparing two different sequences and we want to find out if they contain any highly similar sequence.

\subsubsection{Problem statement}
Similarly as in global alignment, in this problem we search for optimal local alignment according to defined scoring system.
The difference is that we do not know where the alignment in both sequences starts and where it ends.
For example, $ X = TAATAACTCTCTGAATAA $ and $ Y = CGGCGGCGGTCTCTGCC $ can be aligned as in the Figure (\ref{tab:loal}) and the score is calculated just from the first aligned base to the last aligned base.

\begin{table}
  \centering
    \begin{tabular}{ c }
    \verb|--TAATAACTCTCTGAATAA| \\
    \verb%         ||||||     % \\
    \verb|CGGCGGCGGTCTCTGCC---| \\
    \end{tabular}
  \caption{Local alignment example}
  \label{tab:loal}
\end{table} 

\subsubsection{Scoring}
Scoring of local alignment is also similar to global alignment and we are allowed to use the same methods as in global alignment.
Since the score is calculated just from the first aligned base to the last aligned base, the score of our local alignment would be $+1+1+1+1+1+1 = 6$, because there are 6 matches ($+1$) and no gaps ($-1$) or mismatches ($-1$).

\subsubsection{Smith-Waterman algorithm}
Local alignment can be found with dynamic programming algorithm similar to Needleman-Wunsch algorithm.
This is called Smith-Waterman algorithm and there are only two changes compared to Needleman-Wunsch.
First change is that matrix is not initialized with decreasing series, but second row and second column are filled with zeroes.
Second difference is in the rule as follows:\\
Into each cell $A_{i,j}$ write maximum of:
\begin{itemize}
\item $0$,
\item $A_{i-1, j-1} + s()$,
\item $A_{i-1, j} + g()$,
\item $A_{i, j-1} + g()$.
\end{itemize}
After completing the table, we need to find the highest number in it.
This is resulting score of our local alignment.
Following the path similarly as in global alignment we can reconstruct the alignment.
The space and time complexity of this algorithm is also $\mathcal{O}(nm)$.
 
\subsection{Word methods}
Although Needleman-Wunsch and Smith-Waterman algorithms are sufficient for simple comparisons of sequences, their time complexity is not good enough when we want to search through big data.
It is often the case, that we want to find the most similar sequence to ours in enormous bioinformatics database containing several completed genomes.
This is particularly useful if we want to find potential source of our sequence or comparing it to all known proteins to get some indicators about its potential function.
For this purpose various heuristic algorithms were developed.
These algorithms do not guarantee finding the most optimal solution, but are orders of magnitude faster and therefore usable also for searching in vast databases.
  
\subsubsection{BLAST}
Basic Local Alignment Search Tool (BLAST) is probably the most widely used tool in bioinformatics.
% end of session 23.04.2018  
 
\subsubsection{E-value}

\subsection{Alignment in the pipeline}
After dataset splitting we performed local alignment of the genes in training set against themselves.
Thanks to this step we were able to quantify similarities between different genes, which we needed further in pipeline at clustering step.
The standard bioinformatics tool for this purpose is BLAST \cite{blast}. 
The basic algorithm consists of searching seeds from database on the query sequence and then extending those seeds into neighbouring bases.
This approach provides orders of magnitude faster alignment method than classical Smith-Waterman algorithm \cite{smith_waterman} with comparable sensitivity.
In our pipeline we used software CrocoBLAST \cite{crocoblast}, what is a wrapper around BLAST algorithm which make better use of paralellization than standard BLAST maintained by NCBI.
With CrocoBLAST we were able to reduce time of this local alignment step from four days to one day as opposed to BLAST.
Resulting file was in tab separated format, where first column was gene identifier of query sequence, second column was gene identifier of the target sequence and third column was e-value of alignment. 
E-value is evaluation measure of how similar two sequences are.
